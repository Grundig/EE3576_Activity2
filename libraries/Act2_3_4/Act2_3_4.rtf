{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Consolas;}}
{\colortbl\red0\green128\blue0;\red0\green0\blue0;\red255\green0\blue0;\red0\green120\blue215;\red0\green0\blue255;\red128\green0\blue128;}
{\info{\comment Generated by the SynEdit RTF exporter}
{\title Act2_3_4.rtf}}

\deflang1033\pard\plain\f0\fs18 \cf0 #ifndef Act2_2_h
\par #define Act2_2_h
\par 
\par #include <Act2_1.h>
\par 
\par #include<PushButton.h>
\par #include<SerialPrinterPlotter.h>
\par #include<basic_speed_PID.h>
\par #include<DCmotor.h>
\par 
\par \cf1 command_list_enum command\cf2\b ;
\par \cf1 double\b0  target_speed\cf2\b ;
\par \cf1 double\b0  pid_out\cf2\b ;
\par \cf1 long\b0  \b int\b0  start_time\cf2\b ;
\par \cf1 bool\b0  within_error \cf2\b =\b0\cf1  \b false\cf2 ;\b0\cf1  \cf3\i // state flag for the stablilisation
\par \i0\cf1\b bool\b0  stabilised \cf2\b =\b0\cf1  \b false\cf2 ;\b0\cf1  \cf3\i // prevents further messages output
\par 
\par //TASK 4 CODE
\par \i0\cf1 remove\cf2\b (\cf4 "output.txt"\cf2 );\b0\cf1 					\cf3\i //If another copy of output file exists delete it 
\par \i0\cf1 FILE \cf2\b *\b0\cf1  replay_file\cf2\b ;
\par \b0\cf3\i //
\par 
\par \i0\cf1\b class\b0  Act2_3_4\cf2\b \{
\par \b0\cf1 	
\par 	\b protected\cf2 :
\par 
\par \b0\cf1 		\cf3\i // Objects
\par \i0\cf1 		Act2_1 task1\cf2\b ;
\par \b0\cf1 		SerialPrinterPlotter plotter\cf2\b ;
\par \b0\cf1 		basic_speed_PID pid\cf2\b ;
\par \b0\cf1 		inputs pushbuttons\cf2\b ;
\par \b0\cf1 		HBridgeDCmotor HBmotor\cf2\b ;
\par \b0\cf1 		InterruptSpeedMeasure rotate_count\cf2\b ;
\par \b0\cf1 		IntervalCheckTimer button_time_check\cf2\b ,\b0\cf1  target_speed_check\cf2\b ,\b0\cf1  plot_time_check\cf2\b ;
\par \b0\cf1 			
\par 		\cf3\i // Values
\par \i0\cf1 		\b double\b0  motor_low_speed \cf2\b =\b0\cf1  \cf5 77\cf2\b ;\b0\cf1   \cf3\i // 30% rated speed (6000 rpm)
\par \i0\cf1 		\b double\b0  motor_mid_speed \cf2\b =\b0\cf1  \cf5 128\cf2\b ;\b0\cf1   \cf3\i // 50% rated speed
\par \i0\cf1 		\b double\b0  motor_high_speed \cf2\b =\b0\cf1  \cf5 204\cf2\b ;\b0\cf1   \cf3\i // 80% rated speed
\par \i0\cf1 		
\par 		\b double\b0  motor_low_speed_rpm \cf2\b =\b0\cf1  \cf5 1800\cf2\b ;\b0\cf1   \cf3\i // 30% rated speed (6000 rpm)
\par \i0\cf1 		\b double\b0  motor_mid_speed_rpm \cf2\b =\b0\cf1  \cf5 3000\cf2\b ;\b0\cf1   \cf3\i // 50% rated speed
\par \i0\cf1 		\b double\b0  motor_high_speed_rpm \cf2\b =\b0\cf1  \cf5 4800\cf2\b ;\b0\cf1   \cf3\i // 80% rated speed
\par \i0\cf1 		
\par 		\cf3\i // Global variabled
\par \i0\cf1   		\b int\b0  target_speed_time\cf2\b ;
\par \b0\cf1  		\b int\b0  buttons_check_time\cf2\b ;
\par \b0\cf1  		
\par 		
\par 	\b public\cf2 :
\par \b0\cf1 		
\par 		\cf3\i // Set up direction push buttons
\par \i0\cf1 		\b void\b0  setup_motor_pushbuttons\cf2\b (\cf1 int\b0  start_pin\cf2\b ,\b0\cf1  \b int\b0  stop_pin\cf2\b ,\b0\cf1  \b int\b0  reverse_pin\cf2\b )
\par \b0\cf1 		\cf2\b \{
\par \b0\cf1 			\cf3\i // Set long push
\par \i0\cf1 			\b unsigned\b0  \b long\b0  \b int\b0  mininterval_ms\cf2\b =\b0\cf5 2000\cf2\b ;
\par \b0\cf1 			
\par 			\cf3\i // Labelling and assigning each pin
\par \i0\cf1   			in_push_button start_but\cf2\b (\b0\cf1 start_pin\cf2\b ,\b0\cf1  start\cf2\b ,\b0\cf1  mininterval_ms\cf2\b );
\par \b0\cf1   			in_push_button stop_but\cf2\b (\b0\cf1 stop_pin\cf2\b ,\b0\cf1  stop\cf2\b ,\b0\cf1  mininterval_ms\cf2\b );
\par \b0\cf1   			in_push_button reverse_but\cf2\b (\b0\cf1 reverse_pin\cf2\b ,\b0\cf1  reverse\cf2\b ,\b0\cf1  mininterval_ms\cf2\b );
\par \b0\cf1   			
\par   			\cf3\i // Add push button into system
\par \i0\cf1   			pushbuttons\cf2\b .\b0\cf1 add_in_push_button\cf2\b (\b0\cf1 start_but\cf2\b );
\par \b0\cf1  			pushbuttons\cf2\b .\b0\cf1 add_in_push_button\cf2\b (\b0\cf1 stop_but\cf2\b );
\par \b0\cf1   			pushbuttons\cf2\b .\b0\cf1 add_in_push_button\cf2\b (\b0\cf1 reverse_but\cf2\b );
\par \b0\cf1   			
\par 		\cf2\b \}
\par \b0\cf1 		
\par 		\cf3\i // Set up speed push buttons
\par \i0\cf1 		\b void\b0  setup_speed_pushbuttons\cf2\b (\cf1 int\b0  low_speed_pin\cf2\b ,\b0\cf1  \b int\b0  mid_speed_pin\cf2\b ,\b0\cf1  \b int\b0  high_speed_pin\cf2\b )
\par \b0\cf1 		\cf2\b \{
\par \b0\cf1 			\cf3\i // Set long push
\par \i0\cf1 			\b unsigned\b0  \b long\b0  \b int\b0  mininterval_ms\cf2\b =\b0\cf5 2000\cf2\b ;
\par \b0\cf1 			
\par 			\cf3\i // Labelling and assigning each pin
\par \i0\cf1   			in_push_button low_but\cf2\b (\b0\cf1 low_speed_pin\cf2\b ,\b0\cf1  low\cf2\b ,\b0\cf1  mininterval_ms\cf2\b );
\par \b0\cf1   			in_push_button mid_but\cf2\b (\b0\cf1 mid_speed_pin\cf2\b ,\b0\cf1  mid\cf2\b ,\b0\cf1  mininterval_ms\cf2\b );
\par \b0\cf1   			in_push_button high_but\cf2\b (\b0\cf1 high_speed_pin\cf2\b ,\b0\cf1  high\cf2\b ,\b0\cf1  mininterval_ms\cf2\b );
\par \b0\cf1   			
\par   			\cf3\i // Add push button into system
\par \i0\cf1   			pushbuttons\cf2\b .\b0\cf1 add_in_push_button\cf2\b (\b0\cf1 low_but\cf2\b );
\par \b0\cf1  			pushbuttons\cf2\b .\b0\cf1 add_in_push_button\cf2\b (\b0\cf1 mid_but\cf2\b );
\par \b0\cf1   			pushbuttons\cf2\b .\b0\cf1 add_in_push_button\cf2\b (\b0\cf1 high_but\cf2\b );
\par 
\par \b0\cf1 		\cf2\b \}
\par \b0\cf1 		
\par 		\cf3\i // Set up motor
\par \i0\cf1 		\b void\b0  setup_motor\cf2\b (\cf1 int\b0  pwm_motor_pin\cf2\b ,\b0\cf1  \b int\b0  direction_pin\cf2\b )
\par \b0\cf1 		\cf2\b \{
\par \b0\cf1 			HBmotor\cf2\b .\b0\cf1 setup_HBridgeDCmotor\cf2\b (\b0\cf1 pwm_motor_pin\cf2\b ,\b0\cf1  direction_pin\cf2\b );
\par \b0\cf1 		\cf2\b \}
\par \b0\cf1 		
\par 		\cf3\i // Set up speed measuring unit, hall effect sensor
\par \i0\cf1 		\b void\b0  setup_speed_measure\cf2\b (\b0\cf1 ArduinoInterruptNames speed_pin\cf2\b )\b0\cf1   \cf3\i // int_0, pin 2
\par \i0\cf1 		\cf2\b \{
\par \b0\cf1 			rotate_count\cf2\b .\b0\cf1 setupSpeedMeasure\cf2\b (\b0\cf1 speed_pin\cf2\b );
\par \b0\cf1 		\cf2\b \}
\par \b0\cf1 		
\par 		\cf3\i // Set times between checks for components and system
\par \i0\cf1 		\b void\b0  set_time_intervals\cf2\b (\cf1 int\b0  buttons_check_time\cf2\b ,\b0\cf1  \b int\b0  target_speed_time\cf2\b )
\par \b0\cf1 		\cf2\b \{
\par \b0\cf1 			button_time_check\cf2\b .\b0\cf1 setInterCheck\cf2\b (\b0\cf1 buttons_check_time\cf2\b );
\par \b0\cf1 			target_speed_check\cf2\b .\b0\cf1 setInterCheck\cf2\b (\b0\cf1 target_speed_time\cf2\b );
\par \b0\cf1 			plot_time_check\cf2\b .\b0\cf1 setInterCheck\cf2\b (\b0\cf5 200\cf2\b );
\par \b0\cf1 		\cf2\b \}
\par \b0\cf1 		        
\par 		\cf3\i // Determine motor speed command (low, mid, high) from pushbuttons
\par \i0\cf1 		\b void\b0  motor_speed_input\cf2\b (\b0\cf1 command_list_enum command\cf2\b )
\par \b0\cf1 		\cf2\b \{\b0\cf1 	
\par 			\b switch\b0  \cf2\b (\b0\cf1 command\cf2\b )
\par \b0\cf1 			\cf2\b \{
\par \b0\cf1 				\b case\b0  start\cf2\b :
\par \b0\cf1 				start_time \cf2\b =\b0\cf1  millis\cf2\b ();
\par \b0\cf1         		Serial\cf2\b .\b0\cf1 println\cf2\b (\cf4 " Start button pressed"\cf2 );
\par \b0\cf1         		stabilised \cf2\b =\b0\cf1  \b false\cf2 ;
\par \b0\cf1 				HBmotor\cf2\b .\b0\cf1 start\cf2\b ();\b0\cf1 	
\par         		\b break\cf2 ;
\par \b0\cf1         		
\par         		\b case\b0  stop\cf2\b :
\par \b0\cf1         		Serial\cf2\b .\b0\cf1 println\cf2\b (\cf4 "    Stop button pressed"\cf2 );\b0\cf1   
\par         		HBmotor\cf2\b .\b0\cf1 stop\cf2\b ();
\par \b0\cf1         		target_speed\cf2\b =\b0\cf5 0\cf2\b ;\b0\cf1  
\par         		\b break\cf2 ;
\par \b0\cf1         		
\par         		\b case\b0  reverse\cf2\b :
\par \b0\cf1         		Serial\cf2\b .\b0\cf1 println\cf2\b (\cf4 "        Reverse button pressed"\cf2 );
\par \b0\cf1         		HBmotor\cf2\b .\b0\cf1 changedir\cf2\b ();
\par \b0\cf1         		\b break\cf2 ;
\par \b0\cf1         
\par         		\b case\b0  low\cf2\b :
\par \b0\cf1         		Serial\cf2\b .\b0\cf1 println\cf2\b (\cf4 " Low button pressed"\cf2 );
\par \b0\cf1         		target_speed \cf2\b =\b0\cf1  motor_low_speed_rpm\cf2\b ;
\par \b0\cf1         		\b break\cf2 ;
\par \b0\cf1         		
\par         		\b case\b0  mid\cf2\b :
\par \b0\cf1         		Serial\cf2\b .\b0\cf1 println\cf2\b (\cf4 "    Mid button pressed"\cf2 );\b0\cf1   
\par         		target_speed \cf2\b =\b0\cf1  motor_mid_speed_rpm\cf2\b ;
\par \b0\cf1 				\b break\cf2 ;
\par \b0\cf1         		
\par         		\b case\b0  high\cf2\b :
\par \b0\cf1         		Serial\cf2\b .\b0\cf1 println\cf2\b (\cf4 "        High button pressed"\cf2 );
\par \b0\cf1         		target_speed \cf2\b =\b0\cf1  motor_high_speed_rpm\cf2\b ;
\par \b0\cf1         		\b break\cf2 ;
\par \b0\cf1         		
\par         		\b default\cf2 :
\par \b0\cf1           		\b break\cf2 ;
\par \b0\cf1 			\cf2\b \}
\par \b0\cf1 			
\par 		\cf2\b \}
\par \b0\cf1 		
\par 		\cf3\i // Get motor speed from Hall effect sensor (RPM)
\par \i0\cf1 		\b double\b0  read_motor_speed\cf2\b ()
\par \b0\cf1 		\cf2\b \{
\par \b0\cf1 			\b double\b0  RPM\cf2\b =\b0\cf1 rotate_count\cf2\b .\b0\cf1 getRPMandUpdate\cf2\b ();
\par \b0\cf1     		\b return\b0  RPM\cf2\b ;
\par \b0\cf1 		\cf2\b \}
\par \b0\cf1 		
\par 		\cf3\i // Execute the system task
\par \i0\cf1 		\b void\b0  system_execute\cf2\b ()
\par \b0\cf1 		\cf2\b \{\b0\cf1 		
\par 			\b bool\b0  success_command\cf2\b ;
\par \b0\cf1 			\b double\b0  curr_speed\cf2\b ;
\par \b0\cf1 			
\par 			\cf3\i // Check buttons
\par \i0\cf1 			\b if\b0  \cf2\b (\b0\cf1 button_time_check\cf2\b .\b0\cf1 isMinChekTimeElapsedAndUpdate\cf2\b ())
\par \b0\cf1 			\cf2\b \{
\par \b0\cf1 				
\par 				\cf3\i // Get push button command
\par \i0\cf1 				success_command \cf2\b =\b0\cf1  pushbuttons\cf2\b .\b0\cf1 check_n_get_command\cf2\b (\b0\cf1 command\cf2\b );
\par \b0\cf1 			
\par 				\b if\b0  \cf2\b (\b0\cf1 success_command\cf2\b )
\par \b0\cf1 				\cf2\b \{
\par \b0\cf1 					motor_speed_input\cf2\b (\b0\cf1 command\cf2\b );
\par \b0\cf1 				\cf2\b \}
\par \b0\cf1 				
\par 			\cf2\b \}
\par \b0\cf1 				
\par 				
\par 			\cf3\i // PID controller to adjust speed to set point, use target speed check
\par \i0\cf1 			\b if\cf2 (\b0\cf1 target_speed_check\cf2\b .\b0\cf1 isMinChekTimeElapsedAndUpdate\cf2\b ())
\par \b0\cf1 			\cf2\b \{
\par \b0\cf1 				curr_speed \cf2\b =\b0\cf1  read_motor_speed\cf2\b ();
\par \b0\cf1 				\b if\cf2 (\b0\cf1 HBmotor\cf2\b .\b0\cf1 isStarted\cf2\b ())
\par \b0\cf1 				\cf2\b \{
\par \b0\cf1 					pid_out \cf2\b =\b0\cf1  pid\cf2\b .\b0\cf1 ComputePID_output\cf2\b (\b0\cf1 target_speed\cf2\b ,\b0\cf1  curr_speed\cf2\b );
\par \b0\cf1 			
\par 			
\par 					
\par 					HBmotor\cf2\b .\b0\cf1 setSpeedPWM\cf2\b (\b0\cf1 pid_out\cf2\b );
\par \b0\cf1 				\cf2\b \}
\par \b0\cf1 				\b else
\par \b0 					pid\cf2\b .\b0\cf1 reset_pidcontrol\cf2\b ();
\par \b0\cf1 			\cf2\b \}
\par \b0\cf1 			
\par 			
\par 			
\par 			
\par 			\cf3\i // Plot in serial plotter
\par \i0\cf1 			\b if\cf2 (\b0\cf1 plot_time_check\cf2\b .\b0\cf1 isMinChekTimeElapsedAndUpdate\cf2\b ())
\par \b0\cf1 				\cf2\b \{
\par \b0\cf1 					Serial\cf2\b .\b0\cf1 print\cf2\b (\b0\cf5 0\cf2\b );\b0\cf1   \cf3\i // To freeze the lower limit
\par \i0\cf1 					Serial\cf2\b .\b0\cf1 print\cf2\b (\cf4 " "\cf2 );
\par \b0\cf1 					Serial\cf2\b .\b0\cf1 print\cf2\b (\b0\cf5 6000\cf2\b );\b0\cf1   \cf3\i // To freeze the upper limit
\par \i0\cf1 					Serial\cf2\b .\b0\cf1 print\cf2\b (\cf4 " "\cf2 );
\par \b0\cf1 					Serial\cf2\b .\b0\cf1 print\cf2\b (\b0\cf1 target_speed\cf2\b );
\par \b0\cf1 					Serial\cf2\b .\b0\cf1 print\cf2\b (\cf4 " "\cf2 );
\par \b0\cf1 					Serial\cf2\b .\b0\cf1 println\cf2\b (\b0\cf1 curr_speed\cf2\b );\b0\cf1       \cf3\i // X axis is number of samples, i.e, sampled every 0.2 s, so 100 samples taken in 20 s
\par \i0\cf1 					
\par 					\cf3\i //settle time detection
\par \i0\cf1 					\b long\b0  \b int\b0  settle_time\cf2\b ;
\par \b0\cf1 					\b int\b0  stable_time \cf2\b =\b0\cf1  \cf5 2000\cf2\b ;\b0\cf1  \cf3\i //in ms
\par \i0\cf1 					\b double\b0  x_stable \cf2\b =\b0\cf1  \cf5 5\cf2\b ;\b0\cf1  \cf3\i //stable band in %				
\par \i0\cf1 					\b double\b0  error_band \cf2\b =\b0\cf1  target_speed \cf2\b *\b0\cf1  \cf2\b (\b0\cf1 x_stable\cf2\b /\b0\cf5 100\cf2\b );
\par \b0\cf1 					
\par 					\b if\cf2 (!\b0\cf1 stabilised \cf2\b &&\b0\cf1  HBmotor\cf2\b .\b0\cf1 isStarted\cf2\b ())\{
\par \b0\cf1 						\b if\cf2 (\b0\cf1 abs\cf2\b (\b0\cf1 curr_speed\cf2\b -\b0\cf1 target_speed\cf2\b )\b0\cf1  \cf2\b <=\b0\cf1  error_band \cf2\b )\{
\par \b0\cf1 							\b if\cf2 (\b0\cf1 within_error \cf2\b ==\b0\cf1  \b false\cf2 )\{
\par \b0\cf1 								settle_time \cf2\b =\b0\cf1  millis\cf2\b ();
\par \b0\cf1 								within_error \cf2\b =\b0\cf1  \b true\cf2 ;
\par \b0\cf1 							\cf2\b \}
\par \b0\cf1 							
\par 							\b if\cf2 ((\b0\cf1 abs\cf2\b (\b0\cf1 curr_speed\cf2\b -\b0\cf1 target_speed\cf2\b ))\b0\cf1  \cf2\b >\b0\cf1  error_band \cf2\b &&\b0\cf1  within_error \cf2\b ==\b0\cf1  \b true\cf2 )\{
\par \b0\cf1 								within_error \cf2\b =\b0\cf1  \b false\cf2 ;
\par \b0\cf1 								Serial\cf2\b .\b0\cf1 println\cf2\b (\cf4 "ustable"\cf2 );
\par \b0\cf1 							\cf2\b \}
\par \b0\cf1 							
\par 							\b long\b0  \b int\b0  time_since_settle \cf2\b =\b0\cf1  millis\cf2\b ()-\b0\cf1 settle_time\cf2\b ;
\par \b0\cf1 							
\par 							\b if\cf2 ((\b0\cf1 within_error \cf2\b ==\b0\cf1  \b true\cf2 )\b0\cf1  \cf2\b &&\b0\cf1  \cf2\b (\b0\cf1 time_since_settle \cf2\b >=\b0\cf1  stable_time\cf2\b ))\{
\par \b0\cf1 								\b long\b0  \b int\b0  total_settle_time \cf2\b =\b0\cf1  settle_time\cf2\b -\b0\cf1 start_time \cf2\b ;
\par \b0\cf1 								Serial\cf2\b .\b0\cf1 print\cf2\b (\cf4 "System settled in: "\cf2 );
\par \b0\cf1 								Serial\cf2\b .\b0\cf1 print\cf2\b (\b0\cf1 total_settle_time\cf2\b );
\par \b0\cf1 								Serial\cf2\b .\b0\cf1 println\cf2\b (\cf4 " ms"\cf2 );
\par \b0\cf1 								stabilised \cf2\b =\b0\cf1  \b true\cf2 ;
\par \b0\cf1 							\cf2\b \}
\par \b0\cf1 						\cf2\b \}
\par \b0\cf1 						\cf3\i //save to file TASK 4 CODE
\par \i0\cf1 						replay_file \cf2\b =\b0\cf1  fopen\cf2\b (\cf4 "output.txt"\cf2 ,\cf4 "a"\cf2 );\b0\cf1  \cf3\i //open the file in append mode
\par \i0\cf1 						fprintf \cf2\b (\b0\cf1 fp\cf2\b ,\b0\cf1  \cf4\b "%d\\n"\cf2 ,\b0\cf1 curr_speed\cf2\b );\b0\cf1  \cf3\i //save as collumn vector
\par \i0\cf1 						fclose\cf2\b (\b0\cf1 replay_file\cf2\b );
\par \b0\cf1 					\cf2\b \}
\par \b0\cf1 					
\par 				
\par 				\cf2\b \}\b0\cf1 	
\par 		\cf2\b \}
\par \};
\par 
\par 
\par \b0\cf0 #endif
\par }